<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tanks ECS: ULTIMATE</title>
    <style>
        /* --- СТИЛИ (Объединение UI из Кода 1 и Структуры Кода 2) --- */
        body, html { 
            margin: 0; padding: 0; overflow: hidden; background: #1a1a1a; 
            user-select: none; -webkit-user-select: none; touch-action: none;
            font-family: 'Segoe UI', monospace, sans-serif;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        /* UI Контейнер */
        #ui-layer {
            position: absolute; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* Меню настроек (Взято из Кода 1 - фича топ) */
        #settings-wrapper { position: absolute; top: 20px; left: 20px; pointer-events: auto; }
        #gear-btn {
            font-size: 28px; cursor: pointer; background: rgba(0,0,0,0.6);
            border-radius: 50%; width: 50px; height: 50px;
            display: flex; align-items: center; justify-content: center;
            color: #ddd; border: 2px solid #555; transition: 0.2s;
        }
        #gear-btn:active { transform: scale(0.95); background: #333; }
        #settings-menu {
            display: none; background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444; padding: 15px; margin-top: 10px;
            border-radius: 8px; color: white; width: 200px;
        }
        .tank-select {
            background: #333; color: white; border: 1px solid #555;
            padding: 8px; width: 100%; border-radius: 4px; margin-bottom: 10px;
        }
        label { font-size: 10px; text-transform: uppercase; color: #888; display: block; margin-bottom: 4px; }

        /* Статы (HP/Reload) */
        #stats { position: absolute; top: 20px; right: 20px; text-align: right; pointer-events: none; }
        .hp-val { font-size: 28px; font-weight: 900; color: #4f4; text-shadow: 0 0 5px rgba(0,255,0,0.3); }
        .reload-bar { height: 4px; background: #333; width: 100px; margin-top: 5px; align-self: flex-end; }
        .reload-fill { height: 100%; background: #ffaa00; width: 100%; transition: width 0.1s linear; }

        /* Управление (Стиль кнопок из Кода 1, но раскладка адаптивная) */
        #controls-layout {
            position: absolute; bottom: 30px; left: 20px; right: 20px;
            display: flex; justify-content: space-between; align-items: flex-end;
        }
        .control-group { pointer-events: auto; display: flex; flex-direction: column; gap: 8px; }
        .row { display: flex; gap: 8px; }
        
        .btn {
            width: 60px; height: 60px; background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 12px;
            color: rgba(255,255,255,0.7); font-weight: bold; font-size: 18px;
            display: flex; align-items: center; justify-content: center;
        }
        .btn:active { background: rgba(255, 255, 255, 0.25); border-color: white; color: white; }
        .btn-turret { width: 90px; height: 40px; font-size: 12px; text-transform: uppercase; }
        
        #btn-fire {
            width: 90px; height: 90px; background: rgba(200, 50, 50, 0.15);
            border: 2px solid rgba(255, 80, 80, 0.3); border-radius: 50%;
            font-size: 16px; color: #ffaaaa;
        }
        #btn-fire:active { background: rgba(255, 50, 50, 0.5); transform: scale(0.95); }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="settings-wrapper">
        <div id="gear-btn" onclick="toggleSettings(event)">⚙️</div>
        <div id="settings-menu">
            <label>Игрок</label>
            <select id="player-type" class="tank-select" onchange="updateTank('player', this.value)">
                <option value="TT">Тяжелый (Квадрат)</option>
                <option value="ST">Средний (Пятиуг.)</option>
                <option value="LT">Легкий (Ромб)</option>
                <option value="PT">ПТ-САУ (Треуг.)</option>
            </select>
            <label>Противник (ИИ)</label>
            <select id="bot-type" class="tank-select" onchange="updateTank('dummy', this.value)">
                <option value="LT">Легкий</option>
                <option value="ST">Средний</option>
                <option value="TT">Тяжелый</option>
                <option value="PT">ПТ-САУ</option>
            </select>
        </div>
    </div>

    <div id="stats">
        <div class="hp-val" id="player-hp">1000</div>
        <div class="reload-bar"><div class="reload-fill" id="reload-ui"></div></div>
    </div>

    <div id="controls-layout">
        <div class="control-group">
            <div class="row">
                <div class="btn btn-turret" id="btn-q">↺ Turret</div>
                <div class="btn btn-turret" id="btn-e">Turret ↻</div>
            </div>
            <div class="row"><div class="btn" style="width:100%" id="btn-w">W</div></div>
            <div class="row">
                <div class="btn" id="btn-a">A</div>
                <div class="btn" id="btn-s">S</div>
                <div class="btn" id="btn-d">D</div>
            </div>
        </div>
        <div class="control-group">
            <div class="btn" id="btn-fire">FIRE</div>
        </div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * ==================================================
 * PART 1: ЯДРО, МАТЕМАТИКА И СТРУКТУРА ДАННЫХ
 * ==================================================
 */

// --- 1. CONFIG & SPECS (Расширенные данные из Code 2) ---
const TANK_SPECS = {
    TT: { // Тяжелый
        name: 'TT', shape: 'square', hp: 1400,
        speedFwd: 1.5, speedBwd: 1.0, rotSpeed: 0.035,
        armor: { front: 150, side: 80, rear: 40 },
        dmg: 350, reload: 5500, turretType: 'free', color: '#448844'
    },
    PT: { // ПТ-САУ
        name: 'PT', shape: 'triangle', hp: 900,
        speedFwd: 1.8, speedBwd: 1.2, rotSpeed: 0.045,
        armor: { front: 180, side: 40, rear: 20 },
        dmg: 600, reload: 7000, turretType: 'limited', color: '#666688'
    },
    LT: { // Легкий
        name: 'LT', shape: 'rhombus', hp: 700,
        speedFwd: 3.2, speedBwd: 2.5, rotSpeed: 0.09,
        armor: { front: 40, side: 20, rear: 10 },
        dmg: 150, reload: 2200, turretType: 'free', color: '#aaaa44'
    },
    ST: { // Средний
        name: 'ST', shape: 'pentagon', hp: 1100,
        speedFwd: 2.2, speedBwd: 1.8, rotSpeed: 0.06,
        armor: { front: 90, side: 50, rear: 30 },
        dmg: 240, reload: 3500, turretType: 'free', color: '#44aa44'
    }
};

// --- 2. MATH LIBRARY (Улучшенный Vec2 из Code 2) ---
const Vec2 = {
    create: (x, y) => ({ x, y }),
    add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }),
    sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }),
    scale: (v, s) => ({ x: v.x * s, y: v.y * s }),
    dist: (v1, v2) => Math.sqrt((v1.x - v2.x)**2 + (v1.y - v2.y)**2),
    rotate: (v, angle) => ({
        x: v.x * Math.cos(angle) - v.y * Math.sin(angle),
        y: v.x * Math.sin(angle) + v.y * Math.cos(angle)
    }),
    angleDiff: (a, b) => { // Для ИИ и башни
        let diff = b - a;
        while (diff < -Math.PI) diff += Math.PI * 2;
        while (diff > Math.PI) diff -= Math.PI * 2;
        return diff;
    }
};
/* --- ШАГ 1: ЗАМЕНИ ЭТОТ БЛОК --- */
const GeoUtils = {
    // Вычисляет грани танка для честных хитбоксов
    getTankSegments: (tr, spec) => {
        const s = 22; 
        const pos = tr.pos;
        const rot = tr.rotation;
        let localPts = [];

        // Определяем форму хитбокса
        if (spec.shape === 'square') {
            localPts = [{x:s,y:-s,z:'F'}, {x:s,y:s,z:'F'}, {x:-s,y:s,z:'S'}, {x:-s,y:-s,z:'R'}];
        } else if (spec.shape === 'triangle') {
            localPts = [{x:s,y:0,z:'F'}, {x:-s,y:s,z:'S'}, {x:-s,y:-s,z:'R'}];
        } else if (spec.shape === 'rhombus') {
            localPts = [{x:s,y:0,z:'F'}, {x:0,y:s*0.7,z:'S'}, {x:-s,y:0,z:'R'}, {x:0,y:-s*0.7,z:'S'}];
        } else {
            for(let i=0; i<5; i++) {
                const a = i * Math.PI*2/5;
                localPts.push({x:Math.cos(a)*s, y:Math.sin(a)*s, z: i===0?'F':(i<3?'S':'R')});
            }
        }

        const global = localPts.map(p => ({
            x: pos.x + p.x * Math.cos(rot) - p.y * Math.sin(rot),
            y: pos.y + p.x * Math.sin(rot) + p.y * Math.cos(rot),
            zone: p.z
        }));

        const segments = [];
        for(let i=0; i<global.length; i++) {
            segments.push({ p1: global[i], p2: global[(i+1)%global.length], zone: global[i].zone });
        }
        return segments;
    },

    // Пересечение луча и грани
    intersect: (p1, p2, p3, p4) => {
        const det = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
        if (det === 0) return null;
        const t = ((p3.x - p1.x) * (p4.y - p3.y) - (p3.y - p1.y) * (p4.x - p3.x)) / det;
        const u = ((p3.x - p1.x) * (p2.y - p1.y) - (p3.y - p1.y) * (p2.x - p1.x)) / det;
        return (t >= 0 && t <= 1 && u >= 0 && u <= 1) ? { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y), t } : null;
    },

    // Математика рикошета (отражение вектора)
    reflect: (dir, p1, p2) => {
        const dx = p2.x - p1.x, dy = p2.y - p1.y;
        const nx = -dy, ny = dx; 
        const len = Math.sqrt(nx*nx + ny*ny);
        const n = { x: nx/len, y: ny/len };
        const dot = dir.x * n.x + dir.y * n.y;
        return { x: dir.x - 2 * dot * n.x, y: dir.y - 2 * dot * n.y };
    }
};

// --- 3. ECS CORE (Гибкая система из Code 2) ---
class Entity {
    constructor(id) { this.id = id; this.components = {}; }
    addComponent(c) { this.components[c.name] = c; return this; }
    getComponent(n) { return this.components[n]; }
    hasComponent(n) { return !!this.components[n]; }
}

class World {
    constructor() { this.entities = []; this.systems = []; this.idCounter = 0; }
    createEntity() { const e = new Entity(this.idCounter++); this.entities.push(e); return e; }
    addSystem(sys) { this.systems.push(sys); }
    update(dt) { this.systems.forEach(s => s.update(this.entities, dt)); }
}

// --- 4. COMPONENTS (Слияние Code 1 и Code 2) ---
class Component { constructor(name) { this.name = name; } }

class Transform extends Component { 
    constructor(x, y, r = 0) { super('Transform'); this.pos = Vec2.create(x, y); this.rotation = r; } 
}
class TankData extends Component { 
    constructor(type) { 
        super('TankData'); 
        this.spec = TANK_SPECS[type]; 
        this.hp = this.spec.hp; 
        this.maxHp = this.spec.hp;
        this.turretRotation = 0; 
        this.reloadTimer = 0; 
    } 
}
class InputState extends Component { 
    constructor() { 
        super('InputState'); 
        this.keys = { up:0, down:0, left:0, right:0, fire:0, tLeft:0, tRight:0 }; 
    } 
}
class AIBehavior extends Component { // Из Code 1 для ботов
    constructor() { super('AIBehavior'); this.target = null; this.state = 'idle'; } 
}
class RayVisual extends Component { // Из Code 1 для эффектов
    constructor(from, to) { super('RayVisual'); this.from = from; this.to = to; this.life = 1.0; } 
}

// --- 5. INPUT SYSTEM (Обработка ввода) ---
class InputSystem {
    constructor() {
        this.state = { w:0, s:0, a:0, d:0, q:0, e:0, space:0 };
        // Keyboard
        window.addEventListener('keydown', e => this.key(e.key, 1));
        window.addEventListener('keyup', e => this.key(e.key, 0));
        // Touch UI binding
        this.bindTouch('btn-w', 'w'); this.bindTouch('btn-s', 's');
        this.bindTouch('btn-a', 'a'); this.bindTouch('btn-d', 'd');
        this.bindTouch('btn-q', 'q'); this.bindTouch('btn-e', 'e');
        this.bindTouch('btn-fire', 'space');
    }
    key(k, v) {
        const map = { 'w':'w', 's':'s', 'a':'a', 'd':'d', 'q':'q', 'e':'e', ' ':'space', '2':'space' };
        const code = k.toLowerCase();
        if (map[code]) this.state[map[code]] = v;
    }
    bindTouch(id, key) {
        const el = document.getElementById(id);
        if(!el) return;
        const set = (v) => (e) => { if(e.cancelable) e.preventDefault(); this.state[key] = v; };
        el.addEventListener('mousedown', set(1)); el.addEventListener('mouseup', set(0));
        el.addEventListener('touchstart', set(1)); el.addEventListener('touchend', set(0));
    }
    update(entities) {
        entities.forEach(e => {
            if (e.hasComponent('InputState') && !e.hasComponent('AIBehavior')) {
                const k = e.getComponent('InputState').keys;
                const s = this.state;
                k.up = s.w; k.down = s.s; k.left = s.a; k.right = s.d;
                k.tLeft = s.q; k.tRight = s.e; k.fire = s.space;
            }
        });
    }
}

// ... ЧАСТЬ 1 ЗАВЕРШЕНА. 
/**
 * ==================================================
 * PART 2: СИСТЕМЫ ЛОГИКИ, БОЙ И РЕНДЕР
 * ==================================================
 */

// --- 6. AI SYSTEM (Умный бот) ---
class AISystem {
    update(entities, dt) {
        const player = entities.find(e => e.hasComponent('InputState') && !e.hasComponent('AIBehavior'));
        if (!player) return;
        
        entities.forEach(e => {
            if (!e.hasComponent('AIBehavior')) return;
            
            const tr = e.getComponent('Transform');
            const data = e.getComponent('TankData');
            const inp = e.getComponent('InputState').keys;
            const pTr = player.getComponent('Transform');

            // 1. Вычисляем угол и дистанцию до игрока
            const dx = pTr.pos.x - tr.pos.x;
            const dy = pTr.pos.y - tr.pos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const targetAngle = Math.atan2(dy, dx);

            // 2. Поворот корпуса к игроку
            const bodyDiff = Vec2.angleDiff(tr.rotation, targetAngle);
            inp.left = bodyDiff < -0.1 ? 1 : 0;
            inp.right = bodyDiff > 0.1 ? 1 : 0;

            // 3. Движение (держать дистанцию 200-400)
            inp.up = (dist > 350 && Math.abs(bodyDiff) < 1.0) ? 1 : 0;
            inp.down = (dist < 200) ? 1 : 0;

            // 4. Поворот башни (всегда смотрит на врага)
            const turretDiff = Vec2.angleDiff(data.turretRotation, targetAngle);
            inp.tLeft = turretDiff < -0.05 ? 1 : 0;
            inp.tRight = turretDiff > 0.05 ? 1 : 0;

            // 5. Стрельба (если навелся и перезарядился)
            inp.fire = (Math.abs(turretDiff) < 0.1 && dist < 700) ? 1 : 0;
        });
    }
}

// --- 7. MOVEMENT SYSTEM (Физика движения) ---
class MovementSystem {
    update(entities, dt) {
        entities.forEach(e => {
            if (!e.hasComponent('Transform') || !e.hasComponent('TankData') || !e.hasComponent('InputState')) return;

            const tr = e.getComponent('Transform');
            const data = e.getComponent('TankData');
            const k = e.getComponent('InputState').keys;
            const dtSec = dt / 16.6; // Нормализация времени

            // Поворот корпуса
            const rotDir = k.right - k.left;
            tr.rotation += rotDir * data.spec.rotSpeed * dtSec;

            // Движение (Вектор направления корпуса)
            const speed = (k.up ? data.spec.speedFwd : 0) - (k.down ? data.spec.speedBwd : 0);
            if (speed !== 0) {
                const moveDir = { x: Math.cos(tr.rotation), y: Math.sin(tr.rotation) };
                tr.pos.x += moveDir.x * speed * dtSec;
                tr.pos.y += moveDir.y * speed * dtSec;
            }

            // Поворот башни
            const tRotDir = k.tRight - k.tLeft;
            if (data.spec.turretType === 'limited') {
                // Ограничение для ПТ-САУ (башня привязана к корпусу +/- 20 град)
                const targetRot = data.turretRotation + tRotDir * 0.04 * dtSec;
                const diff = Vec2.angleDiff(tr.rotation, targetRot);
                if (Math.abs(diff) < 0.4) data.turretRotation = targetRot;
                else {
                    // Если не крутим башней, она медленно возвращается к центру
                    if (tRotDir === 0) {
                        data.turretRotation += Vec2.angleDiff(data.turretRotation, tr.rotation) * 0.1;
                    }
                }
            } else {
                // Свободная башня
                data.turretRotation += tRotDir * 0.05 * dtSec;
            }
        });
    }
}

// --- 8. COMBAT SYSTEM (Rays & Armor Calculation) ---
/* --- ШАГ 2: ПОЛНОСТЬЮ ЗАМЕНИ ЭТОТ КЛАСС --- */
class CombatSystem {
    constructor(world) { 
        this.world = world;
        this.walls = [ // Добавляем физические стены на карту
            {p1: {x:200, y:-300}, p2: {x:200, y:300}},
            {p1: {x:-300, y:150}, p2: {x:400, y:150}}
        ];
    }

    update(entities, dt) {
        entities.forEach(e => {
            if (e.hasComponent('TankData')) {
                const d = e.getComponent('TankData');
                if (d.reloadTimer > 0) d.reloadTimer -= dt;
                if (e.getComponent('InputState').keys.fire && d.reloadTimer <= 0) {
                    this.shoot(e);
                    d.reloadTimer = d.spec.reload;
                }
            }
        });
    }

    shoot(shooter) {
        const tr = shooter.getComponent('Transform');
        const data = shooter.getComponent('TankData');
        let start = { x: tr.pos.x, y: tr.pos.y };
        let dir = { x: Math.cos(data.turretRotation), y: Math.sin(data.turretRotation) };
        this.castRay(shooter, start, dir, 0);
    }

    castRay(shooter, start, dir, bounce) {
        if (bounce > 2) return; // Максимум 2 рикошета

        const end = { x: start.x + dir.x * 1200, y: start.y + dir.y * 1200 };
        let closest = null;

        // Проверка столкновения с гранями ТАНКОВ
        this.world.entities.forEach(target => {
            if (target === shooter || !target.hasComponent('TankData')) return;
            const segments = GeoUtils.getTankSegments(target.getComponent('Transform'), target.getComponent('TankData').spec);
            segments.forEach(seg => {
                const hit = GeoUtils.intersect(start, end, seg.p1, seg.p2);
                if (hit && (!closest || hit.t < closest.t)) 
                    closest = { ...hit, type: 'tank', entity: target, segment: seg };
            });
        });

        // Проверка столкновения со СТЕНАМИ
        this.walls.forEach(wall => {
            const hit = GeoUtils.intersect(start, end, wall.p1, wall.p2);
            if (hit && (!closest || hit.t < closest.t)) 
                closest = { ...hit, type: 'wall', segment: wall };
        });

        const hitPos = closest ? {x: closest.x, y: closest.y} : end;
        this.world.createEntity().addComponent(new RayVisual(start, hitPos));

        if (closest) {
            const reflectDir = GeoUtils.reflect(dir, closest.segment.p1, closest.segment.p2);
            if (closest.type === 'tank') {
                this.handleTankHit(shooter, closest, dir, reflectDir, bounce);
            } else {
                this.castRay(shooter, hitPos, reflectDir, bounce + 1);
            }
        }
    }

    handleTankHit(shooter, hit, oldDir, newDir, bounce) {
        const target = hit.entity.getComponent('TankData');
        const armor = (hit.segment.zone === 'F') ? target.spec.armor.front : (hit.segment.zone === 'R' ? target.spec.armor.rear : target.spec.armor.side);
        
        // Условие рикошета: если угол падения слишком острый
        const dot = Math.abs(oldDir.x * (hit.segment.p1.x - hit.segment.p2.x) + oldDir.y * (hit.segment.p1.y - hit.segment.p2.y));
        
        if (dot < 10 || armor > 150) { // Рикошет
            this.castRay(shooter, {x: hit.x, y: hit.y}, newDir, bounce + 1);
        } else { // Пробитие
            target.hp -= shooter.getComponent('TankData').spec.dmg;
            if (target.hp <= 0) { 
                hit.entity.getComponent('Transform').pos = {x: (Math.random()-0.5)*1000, y: (Math.random()-0.5)*1000};
                target.hp = target.spec.hp;
            }
        }
    }
}
// --- 9. RENDER SYSTEM (Визуал) ---
class RenderSystem {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        window.addEventListener('resize', () => this.resize());
        this.resize();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    drawShape(ctx, shape) {
        ctx.beginPath();
        const s = 22; // Размер танка
        if (shape === 'square') ctx.rect(-s, -s, s*2, s*2); // TT
        else if (shape === 'triangle') { // PT
            ctx.moveTo(s, 0); ctx.lineTo(-s, s); ctx.lineTo(-s, -s); ctx.closePath();
        } 
        else if (shape === 'rhombus') { // LT
            ctx.moveTo(s, 0); ctx.lineTo(0, s*0.7); ctx.lineTo(-s, 0); ctx.lineTo(0, -s*0.7); ctx.closePath();
        }
        else if (shape === 'pentagon') { // ST
            for(let i=0; i<5; i++) {
                const a = i * Math.PI*2/5;
                const x = Math.cos(a)*s, y = Math.sin(a)*s;
                i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
            }
            ctx.closePath();
        }
        ctx.fill(); ctx.stroke();
    }

    update(entities) {
        const ctx = this.ctx;
        const player = entities.find(e => e.hasComponent('InputState') && !e.hasComponent('AIBehavior'));
        const cam = player ? player.getComponent('Transform').pos : {x:0, y:0};

        // Фон
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        ctx.save();
        // Камера
        ctx.translate(this.canvas.width/2 - cam.x, this.canvas.height/2 - cam.y);

        // Сетка
        ctx.strokeStyle = '#282828'; ctx.lineWidth = 2;
        const gridSize = 100;
        const range = 2000;
        ctx.beginPath();
        for(let i=-range; i<=range; i+=gridSize) {
            ctx.moveTo(i, -range); ctx.lineTo(i, range);
            ctx.moveTo(-range, i); ctx.lineTo(range, i);
        }
        ctx.stroke();
        /* --- ШАГ 3: ВСТАВЬ ВНУТРЬ RenderSystem.update --- */
ctx.strokeStyle = '#fff'; ctx.lineWidth = 4;
const combat = this.world.systems.find(s => s instanceof CombatSystem);
if (combat) {
    combat.walls.forEach(w => {
        ctx.beginPath(); ctx.moveTo(w.p1.x, w.p1.y); ctx.lineTo(w.p2.x, w.p2.y); ctx.stroke();
    });
}
        
        // Отрисовка сущностей
        entities.forEach(e => {
            // ТАНКИ
            if (e.hasComponent('TankData')) {
                const tr = e.getComponent('Transform');
                const data = e.getComponent('TankData');
                
                ctx.save();
                ctx.translate(tr.pos.x, tr.pos.y);

                // Корпус
                ctx.save();
                ctx.rotate(tr.rotation);
                ctx.fillStyle = data.spec.color;
                ctx.shadowBlur = 10; ctx.shadowColor = data.spec.color;
                ctx.lineWidth = 3; ctx.strokeStyle = '#000';
                this.drawShape(ctx, data.spec.shape);
                ctx.shadowBlur = 0;
                
                // HP Bar над танком
                ctx.fillStyle = 'red'; ctx.fillRect(-20, -40, 40, 4);
                ctx.fillStyle = '#0f0'; ctx.fillRect(-20, -40, 40 * (data.hp / data.spec.hp), 4);
                ctx.restore();

                // Башня
                ctx.save();
                ctx.rotate(data.turretRotation);
                ctx.fillStyle = '#333';
                ctx.strokeStyle = '#111';
                // Дуло
                ctx.fillRect(0, -6, 35, 12); ctx.strokeRect(0, -6, 35, 12);
                // Башня (круг)
                ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI*2); 
                ctx.fill(); ctx.stroke();
                ctx.restore();

                ctx.restore();
            }

            // ЛУЧИ (ВЫСТРЕЛЫ)
            if (e.hasComponent('RayVisual')) {
                const rv = e.getComponent('RayVisual');
                ctx.globalAlpha = rv.life;
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.beginPath(); 
                ctx.moveTo(rv.from.x, rv.from.y); 
                ctx.lineTo(rv.to.x, rv.to.y); 
                ctx.stroke();
                
                // Искра
                ctx.fillStyle = 'orange';
                ctx.beginPath(); ctx.arc(rv.to.x, rv.to.y, 5, 0, Math.PI*2); ctx.fill();

                ctx.globalAlpha = 1.0;
                rv.life -= 0.1; // Затухание
                if(rv.life <= 0) e.kill = true; // Помечаем на удаление
            }
        });
        
        // Удаление мертвых эффектов
        for(let i = entities.length - 1; i >= 0; i--) {
            if(entities[i].kill) entities.splice(i, 1);
        }

        ctx.restore();

        // UI Update
        if (player) {
            const pd = player.getComponent('TankData');
            document.getElementById('player-hp').innerText = Math.max(0, Math.round(pd.hp));
            const reloadPerc = Math.min(100, 100 - (pd.reloadTimer / pd.spec.reload * 100));
            document.getElementById('reload-ui').style.width = reloadPerc + '%';
            document.getElementById('reload-ui').style.background = reloadPerc >= 100 ? '#0f0' : '#fa0';
        }
    }
}

// --- 10. ЗАПУСК ИГРЫ (INIT) ---
const world = new World();
const inputSys = new InputSystem();
world.addSystem(inputSys);
world.addSystem(new AISystem());
world.addSystem(new MovementSystem());
world.addSystem(new CombatSystem(world));
const renderSys = new RenderSystem();

// Создание сущностей
const player = world.createEntity()
    .addComponent(new Transform(0, 0))
    .addComponent(new TankData('TT')) // Начинаем на Тяжелом
    .addComponent(new InputState());

const enemy = world.createEntity()
    .addComponent(new Transform(300, 300))
    .addComponent(new TankData('LT'))
    .addComponent(new InputState())
    .addComponent(new AIBehavior());

// Глобальный доступ для UI
window.gameEntities = { player, dummy: enemy };

// Функции UI
window.toggleSettings = (e) => {
    e.stopPropagation();
    const el = document.getElementById('settings-menu');
    el.style.display = el.style.display === 'block' ? 'none' : 'block';
};

window.updateTank = (key, type) => {
    const e = window.gameEntities[key];
    if(e) {
        const data = e.getComponent('TankData');
        const oldHpPerc = data.hp / data.spec.hp;
        data.spec = TANK_SPECS[type];
        data.hp = data.spec.hp * oldHpPerc; // Сохраняем % здоровья при смене
        data.maxHp = data.spec.hp;
    }
};

// Главный цикл
let lastTime = performance.now();
function loop(now) {
    const dt = now - lastTime;
    lastTime = now;
    
    world.update(dt);
    renderSys.update(world.entities);
    
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
