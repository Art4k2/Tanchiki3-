<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tanks ECS: ULTIMATE</title>
    <style>
        /* --- СТИЛИ (Объединение UI из Кода 1 и Структуры Кода 2) --- */
        body, html { 
            margin: 0; padding: 0; overflow: hidden; background: #1a1a1a; 
            user-select: none; -webkit-user-select: none; touch-action: none;
            font-family: 'Segoe UI', monospace, sans-serif;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        /* UI Контейнер */
        #ui-layer {
            position: absolute; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* Меню настроек (Взято из Кода 1 - фича топ) */
        #settings-wrapper { position: absolute; top: 20px; left: 20px; pointer-events: auto; }
        #gear-btn {
            font-size: 28px; cursor: pointer; background: rgba(0,0,0,0.6);
            border-radius: 50%; width: 50px; height: 50px;
            display: flex; align-items: center; justify-content: center;
            color: #ddd; border: 2px solid #555; transition: 0.2s;
        }
        #gear-btn:active { transform: scale(0.95); background: #333; }
        #settings-menu {
            display: none; background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444; padding: 15px; margin-top: 10px;
            border-radius: 8px; color: white; width: 200px;
        }
        .tank-select {
            background: #333; color: white; border: 1px solid #555;
            padding: 8px; width: 100%; border-radius: 4px; margin-bottom: 10px;
        }
        label { font-size: 10px; text-transform: uppercase; color: #888; display: block; margin-bottom: 4px; }

        /* Статы (HP/Reload) */
        #stats { position: absolute; top: 20px; right: 20px; text-align: right; pointer-events: none; }
        .hp-val { font-size: 28px; font-weight: 900; color: #4f4; text-shadow: 0 0 5px rgba(0,255,0,0.3); }
        .reload-bar { height: 4px; background: #333; width: 100px; margin-top: 5px; align-self: flex-end; }
        .reload-fill { height: 100%; background: #ffaa00; width: 100%; transition: width 0.1s linear; }

        /* Управление (Стиль кнопок из Кода 1, но раскладка адаптивная) */
        #controls-layout {
            position: absolute; bottom: 30px; left: 20px; right: 20px;
            display: flex; justify-content: space-between; align-items: flex-end;
        }
        .control-group { pointer-events: auto; display: flex; flex-direction: column; gap: 8px; }
        .row { display: flex; gap: 8px; }
        
        .btn {
            width: 60px; height: 60px; background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 12px;
            color: rgba(255,255,255,0.7); font-weight: bold; font-size: 18px;
            display: flex; align-items: center; justify-content: center;
        }
        .btn:active { background: rgba(255, 255, 255, 0.25); border-color: white; color: white; }
        .btn-turret { width: 90px; height: 40px; font-size: 12px; text-transform: uppercase; }
        
        #btn-fire {
            width: 90px; height: 90px; background: rgba(200, 50, 50, 0.15);
            border: 2px solid rgba(255, 80, 80, 0.3); border-radius: 50%;
            font-size: 16px; color: #ffaaaa;
        }
        #btn-fire:active { background: rgba(255, 50, 50, 0.5); transform: scale(0.95); }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="settings-wrapper">
        <div id="gear-btn" onclick="toggleSettings(event)">⚙️</div>
        <div id="settings-menu">
            <label>Игрок</label>
            <select id="player-type" class="tank-select" onchange="updateTank('player', this.value)">
                <option value="TT">Тяжелый (Квадрат)</option>
                <option value="ST">Средний (Пятиуг.)</option>
                <option value="LT">Легкий (Ромб)</option>
                <option value="PT">ПТ-САУ (Треуг.)</option>
            </select>
            <label>Противник (ИИ)</label>
            <select id="bot-type" class="tank-select" onchange="updateTank('dummy', this.value)">
                <option value="LT">Легкий</option>
                <option value="ST">Средний</option>
                <option value="TT">Тяжелый</option>
                <option value="PT">ПТ-САУ</option>
            </select>
        </div>
    </div>

    <div id="stats">
        <div class="hp-val" id="player-hp">1000</div>
        <div class="reload-bar"><div class="reload-fill" id="reload-ui"></div></div>
    </div>

    <div id="controls-layout">
        <div class="control-group">
            <div class="row">
                <div class="btn btn-turret" id="btn-q">↺ Turret</div>
                <div class="btn btn-turret" id="btn-e">Turret ↻</div>
            </div>
            <div class="row"><div class="btn" style="width:100%" id="btn-w">W</div></div>
            <div class="row">
                <div class="btn" id="btn-a">A</div>
                <div class="btn" id="btn-s">S</div>
                <div class="btn" id="btn-d">D</div>
            </div>
        </div>
        <div class="control-group">
            <div class="btn" id="btn-fire">FIRE</div>
        </div>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * ==================================================
 * PART 1: ЯДРО, МАТЕМАТИКА И СТРУКТУРА ДАННЫХ
 * ==================================================
 */

// --- 1. CONFIG & SPECS (Расширенные данные из Code 2) ---
const TANK_SPECS = {
    TT: { // Тяжелый
        name: 'TT', shape: 'square', hp: 1400,
        speedFwd: 1.5, speedBwd: 1.0, rotSpeed: 0.035,
        armor: { front: 150, side: 80, rear: 40 },
        dmg: 350, reload: 5500, turretType: 'free', color: '#448844'
    },
    PT: { // ПТ-САУ
        name: 'PT', shape: 'triangle', hp: 900,
        speedFwd: 1.8, speedBwd: 1.2, rotSpeed: 0.045,
        armor: { front: 180, side: 40, rear: 20 },
        dmg: 600, reload: 7000, turretType: 'limited', color: '#666688'
    },
    LT: { // Легкий
        name: 'LT', shape: 'rhombus', hp: 700,
        speedFwd: 3.2, speedBwd: 2.5, rotSpeed: 0.09,
        armor: { front: 40, side: 20, rear: 10 },
        dmg: 150, reload: 2200, turretType: 'free', color: '#aaaa44'
    },
    ST: { // Средний
        name: 'ST', shape: 'pentagon', hp: 1100,
        speedFwd: 2.2, speedBwd: 1.8, rotSpeed: 0.06,
        armor: { front: 90, side: 50, rear: 30 },
        dmg: 240, reload: 3500, turretType: 'free', color: '#44aa44'
    }
};

// --- 2. MATH LIBRARY (Улучшенный Vec2 из Code 2) ---
const Vec2 = {
    create: (x, y) => ({ x, y }),
    add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }),
    sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }),
    scale: (v, s) => ({ x: v.x * s, y: v.y * s }),
    dist: (v1, v2) => Math.sqrt((v1.x - v2.x)**2 + (v1.y - v2.y)**2),
    rotate: (v, angle) => ({
        x: v.x * Math.cos(angle) - v.y * Math.sin(angle),
        y: v.x * Math.sin(angle) + v.y * Math.cos(angle)
    }),
    angleDiff: (a, b) => { // Для ИИ и башни
        let diff = b - a;
        while (diff < -Math.PI) diff += Math.PI * 2;
        while (diff > Math.PI) diff -= Math.PI * 2;
        return diff;
    }
};

// --- 3. ECS CORE (Гибкая система из Code 2) ---
class Entity {
    constructor(id) { this.id = id; this.components = {}; }
    addComponent(c) { this.components[c.name] = c; return this; }
    getComponent(n) { return this.components[n]; }
    hasComponent(n) { return !!this.components[n]; }
}

class World {
    constructor() { this.entities = []; this.systems = []; this.idCounter = 0; }
    createEntity() { const e = new Entity(this.idCounter++); this.entities.push(e); return e; }
    addSystem(sys) { this.systems.push(sys); }
    update(dt) { this.systems.forEach(s => s.update(this.entities, dt)); }
}

// --- 4. COMPONENTS (Слияние Code 1 и Code 2) ---
class Component { constructor(name) { this.name = name; } }

class Transform extends Component { 
    constructor(x, y, r = 0) { super('Transform'); this.pos = Vec2.create(x, y); this.rotation = r; } 
}
class TankData extends Component { 
    constructor(type) { 
        super('TankData'); 
        this.spec = TANK_SPECS[type]; 
        this.hp = this.spec.hp; 
        this.maxHp = this.spec.hp;
        this.turretRotation = 0; 
        this.reloadTimer = 0; 
    } 
}
class InputState extends Component { 
    constructor() { 
        super('InputState'); 
        this.keys = { up:0, down:0, left:0, right:0, fire:0, tLeft:0, tRight:0 }; 
    } 
}
class AIBehavior extends Component { // Из Code 1 для ботов
    constructor() { super('AIBehavior'); this.target = null; this.state = 'idle'; } 
}
class RayVisual extends Component { // Из Code 1 для эффектов
    constructor(from, to) { super('RayVisual'); this.from = from; this.to = to; this.life = 1.0; } 
}

// --- 5. INPUT SYSTEM (Обработка ввода) ---
class InputSystem {
    constructor() {
        this.state = { w:0, s:0, a:0, d:0, q:0, e:0, space:0 };
        // Keyboard
        window.addEventListener('keydown', e => this.key(e.key, 1));
        window.addEventListener('keyup', e => this.key(e.key, 0));
        // Touch UI binding
        this.bindTouch('btn-w', 'w'); this.bindTouch('btn-s', 's');
        this.bindTouch('btn-a', 'a'); this.bindTouch('btn-d', 'd');
        this.bindTouch('btn-q', 'q'); this.bindTouch('btn-e', 'e');
        this.bindTouch('btn-fire', 'space');
    }
    key(k, v) {
        const map = { 'w':'w', 's':'s', 'a':'a', 'd':'d', 'q':'q', 'e':'e', ' ':'space', '2':'space' };
        const code = k.toLowerCase();
        if (map[code]) this.state[map[code]] = v;
    }
    bindTouch(id, key) {
        const el = document.getElementById(id);
        if(!el) return;
        const set = (v) => (e) => { if(e.cancelable) e.preventDefault(); this.state[key] = v; };
        el.addEventListener('mousedown', set(1)); el.addEventListener('mouseup', set(0));
        el.addEventListener('touchstart', set(1)); el.addEventListener('touchend', set(0));
    }
    update(entities) {
        entities.forEach(e => {
            if (e.hasComponent('InputState') && !e.hasComponent('AIBehavior')) {
                const k = e.getComponent('InputState').keys;
                const s = this.state;
                k.up = s.w; k.down = s.s; k.left = s.a; k.right = s.d;
                k.tLeft = s.q; k.tRight = s.e; k.fire = s.space;
            }
        });
    }
}

// ... ЧАСТЬ 1 ЗАВЕРШЕНА. 
/**
 * ==================================================
 * PART 2: СИСТЕМЫ ЛОГИКИ, БОЙ И РЕНДЕР
 * ==================================================
 */

// --- 6. AI SYSTEM (Умный бот) ---
class AISystem {
    update(entities, dt) {
        const player = entities.find(e => e.hasComponent('InputState') && !e.hasComponent('AIBehavior'));
        if (!player) return;
        
        entities.forEach(e => {
            if (!e.hasComponent('AIBehavior')) return;
            
            const tr = e.getComponent('Transform');
            const data = e.getComponent('TankData');
            const inp = e.getComponent('InputState').keys;
            const pTr = player.getComponent('Transform');

            // 1. Вычисляем угол и дистанцию до игрока
            const dx = pTr.pos.x - tr.pos.x;
            const dy = pTr.pos.y - tr.pos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const targetAngle = Math.atan2(dy, dx);

            // 2. Поворот корпуса к игроку
            const bodyDiff = Vec2.angleDiff(tr.rotation, targetAngle);
            inp.left = bodyDiff < -0.1 ? 1 : 0;
            inp.right = bodyDiff > 0.1 ? 1 : 0;

            // 3. Движение (держать дистанцию 200-400)
            inp.up = (dist > 350 && Math.abs(bodyDiff) < 1.0) ? 1 : 0;
            inp.down = (dist < 200) ? 1 : 0;

            // 4. Поворот башни (всегда смотрит на врага)
            const turretDiff = Vec2.angleDiff(data.turretRotation, targetAngle);
            inp.tLeft = turretDiff < -0.05 ? 1 : 0;
            inp.tRight = turretDiff > 0.05 ? 1 : 0;

            // 5. Стрельба (если навелся и перезарядился)
            inp.fire = (Math.abs(turretDiff) < 0.1 && dist < 700) ? 1 : 0;
        });
    }
}

// --- 7. MOVEMENT SYSTEM (Физика движения) ---
class MovementSystem {
    update(entities, dt) {
        entities.forEach(e => {
            if (!e.hasComponent('Transform') || !e.hasComponent('TankData') || !e.hasComponent('InputState')) return;

            const tr = e.getComponent('Transform');
            const data = e.getComponent('TankData');
            const k = e.getComponent('InputState').keys;
            const dtSec = dt / 16.6; // Нормализация времени

            // Поворот корпуса
            const rotDir = k.right - k.left;
            tr.rotation += rotDir * data.spec.rotSpeed * dtSec;

            // Движение (Вектор направления корпуса)
            const speed = (k.up ? data.spec.speedFwd : 0) - (k.down ? data.spec.speedBwd : 0);
            if (speed !== 0) {
                const moveDir = { x: Math.cos(tr.rotation), y: Math.sin(tr.rotation) };
                tr.pos.x += moveDir.x * speed * dtSec;
                tr.pos.y += moveDir.y * speed * dtSec;
            }

            // Поворот башни
            const tRotDir = k.tRight - k.tLeft;
            if (data.spec.turretType === 'limited') {
                // Ограничение для ПТ-САУ (башня привязана к корпусу +/- 20 град)
                const targetRot = data.turretRotation + tRotDir * 0.04 * dtSec;
                const diff = Vec2.angleDiff(tr.rotation, targetRot);
                if (Math.abs(diff) < 0.4) data.turretRotation = targetRot;
                else {
                    // Если не крутим башней, она медленно возвращается к центру
                    if (tRotDir === 0) {
                        data.turretRotation += Vec2.angleDiff(data.turretRotation, tr.rotation) * 0.1;
                    }
                }
            } else {
                // Свободная башня
                data.turretRotation += tRotDir * 0.05 * dtSec;
            }
        });
    }
}

// --- 8. COMBAT SYSTEM (Rays & Armor Calculation) ---
class CombatSystem {
    constructor(world) { this.world = world; }
    
    update(entities, dt) {
        entities.forEach(shooter => {
            if (!shooter.hasComponent('TankData')) return;
            const data = shooter.getComponent('TankData');
            const inp = shooter.getComponent('InputState').keys;

            // Перезарядка
            if (data.reloadTimer > 0) data.reloadTimer -= dt;

            // Выстрел
            if (inp.fire && data.reloadTimer <= 0) {
                this.fire(shooter);
                data.reloadTimer = data.spec.reload;
            }
        });
    }

    fire(shooter) {
        const tr = shooter.getComponent('Transform');
        const data = shooter.getComponent('TankData');
        
        // Точка вылета (дуло)
        const offset = 35;
        const start = {
            x: tr.pos.x + Math.cos(data.turretRotation) * offset,
            y: tr.pos.y + Math.sin(data.turretRotation) * offset
        };
        const dir = { x: Math.cos(data.turretRotation), y: Math.sin(data.turretRotation) };

        // Raycast
        let bestHit = null;
        let minDist = 1000;

        this.world.entities.forEach(target => {
            if (target === shooter || !target.hasComponent('TankData')) return;
            
            // Упрощенная коллизия (круг) для быстродействия
            const tTr = target.getComponent('Transform');
            
            // Проекция точки центра танка на луч
            const vToTarget = { x: tTr.pos.x - start.x, y: tTr.pos.y - start.y };
            const dot = vToTarget.x * dir.x + vToTarget.y * dir.y;
            
            if (dot > 0) { // Если танк спереди
                const closestPoint = { x: start.x + dir.x * dot, y: start.y + dir.y * dot };
                const distToRay = Vec2.dist(closestPoint, tTr.pos);
                
                if (distToRay < 25) { // Попали в хитбокс (радиус 25)
                    const dist = Vec2.dist(start, closestPoint);
                    if (dist < minDist) {
                        minDist = dist;
                        bestHit = { entity: target, pos: closestPoint };
                    }
                }
            }
        });

        const end = bestHit ? bestHit.pos : { x: start.x + dir.x * 1000, y: start.y + dir.y * 1000 };
        
        // Визуализация луча
        this.world.createEntity().addComponent(new RayVisual(start, end));

        // Нанесение урона
        if (bestHit) {
            this.resolveHit(shooter, bestHit.entity, dir);
        }
    }

    resolveHit(shooter, target, shotDir) {
        const tTr = target.getComponent('Transform');
        const tData = target.getComponent('TankData');
        const sData = shooter.getComponent('TankData');

        // Определяем зону попадания (сравниваем угол выстрела и поворот танка)
        const shotAngle = Math.atan2(shotDir.y, shotDir.x);
        // Угол попадания относительно носа танка
        let impactAngle = Vec2.angleDiff(tTr.rotation, shotAngle);
        impactAngle = Math.abs(impactAngle); // 0 = в корму, PI = в лоб

        let armor = 0;
        let zone = '';

        // Логика зон пробития (Лоб/Борт/Корма)
        if (impactAngle > 2.5) { zone = 'FRONT'; armor = tData.spec.armor.front; }
        else if (impactAngle < 0.8) { zone = 'REAR'; armor = tData.spec.armor.rear; }
        else { zone = 'SIDE'; armor = tData.spec.armor.side; }

        // Расчет урона (База + Рандом - Броня/2) -> Упростим для играбельности
        // Если пробой > брони -> полный урон.
        // Эмулируем пробитие: 
        const penetration = 200; // Условное пробитие снаряда
        let dmg = 0;

        if (penetration >= armor) {
            dmg = sData.spec.dmg * (0.8 + Math.random() * 0.4); // +/- 20%
            tData.hp -= dmg;
            console.log(`Hit ${zone}! DMG: ${Math.round(dmg)}`);
        } else {
            console.log(`RICOCHET on ${zone}!`);
            // Рикошет можно визуализировать короткой искрой
        }

        // Смерть
        if (tData.hp <= 0) {
            this.respawn(target);
        }
    }

    respawn(entity) {
        const tData = entity.getComponent('TankData');
        const tr = entity.getComponent('Transform');
        tData.hp = tData.spec.hp;
        // Респаун в случайной точке подальше
        tr.pos.x = (Math.random() - 0.5) * 1000;
        tr.pos.y = (Math.random() - 0.5) * 1000;
    }
}

// --- 9. RENDER SYSTEM (Визуал) ---
class RenderSystem {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        window.addEventListener('resize', () => this.resize());
        this.resize();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    drawShape(ctx, shape) {
        ctx.beginPath();
        const s = 22; // Размер танка
        if (shape === 'square') ctx.rect(-s, -s, s*2, s*2); // TT
        else if (shape === 'triangle') { // PT
            ctx.moveTo(s, 0); ctx.lineTo(-s, s); ctx.lineTo(-s, -s); ctx.closePath();
        } 
        else if (shape === 'rhombus') { // LT
            ctx.moveTo(s, 0); ctx.lineTo(0, s*0.7); ctx.lineTo(-s, 0); ctx.lineTo(0, -s*0.7); ctx.closePath();
        }
        else if (shape === 'pentagon') { // ST
            for(let i=0; i<5; i++) {
                const a = i * Math.PI*2/5;
                const x = Math.cos(a)*s, y = Math.sin(a)*s;
                i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
            }
            ctx.closePath();
        }
        ctx.fill(); ctx.stroke();
    }

    update(entities) {
        const ctx = this.ctx;
        const player = entities.find(e => e.hasComponent('InputState') && !e.hasComponent('AIBehavior'));
        const cam = player ? player.getComponent('Transform').pos : {x:0, y:0};

        // Фон
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        ctx.save();
        // Камера
        ctx.translate(this.canvas.width/2 - cam.x, this.canvas.height/2 - cam.y);

        // Сетка
        ctx.strokeStyle = '#282828'; ctx.lineWidth = 2;
        const gridSize = 100;
        const range = 2000;
        ctx.beginPath();
        for(let i=-range; i<=range; i+=gridSize) {
            ctx.moveTo(i, -range); ctx.lineTo(i, range);
            ctx.moveTo(-range, i); ctx.lineTo(range, i);
        }
        ctx.stroke();

        // Отрисовка сущностей
        entities.forEach(e => {
            // ТАНКИ
            if (e.hasComponent('TankData')) {
                const tr = e.getComponent('Transform');
                const data = e.getComponent('TankData');
                
                ctx.save();
                ctx.translate(tr.pos.x, tr.pos.y);

                // Корпус
                ctx.save();
                ctx.rotate(tr.rotation);
                ctx.fillStyle = data.spec.color;
                ctx.shadowBlur = 10; ctx.shadowColor = data.spec.color;
                ctx.lineWidth = 3; ctx.strokeStyle = '#000';
                this.drawShape(ctx, data.spec.shape);
                ctx.shadowBlur = 0;
                
                // HP Bar над танком
                ctx.fillStyle = 'red'; ctx.fillRect(-20, -40, 40, 4);
                ctx.fillStyle = '#0f0'; ctx.fillRect(-20, -40, 40 * (data.hp / data.spec.hp), 4);
                ctx.restore();

                // Башня
                ctx.save();
                ctx.rotate(data.turretRotation);
                ctx.fillStyle = '#333';
                ctx.strokeStyle = '#111';
                // Дуло
                ctx.fillRect(0, -6, 35, 12); ctx.strokeRect(0, -6, 35, 12);
                // Башня (круг)
                ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI*2); 
                ctx.fill(); ctx.stroke();
                ctx.restore();

                ctx.restore();
            }

            // ЛУЧИ (ВЫСТРЕЛЫ)
            if (e.hasComponent('RayVisual')) {
                const rv = e.getComponent('RayVisual');
                ctx.globalAlpha = rv.life;
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.beginPath(); 
                ctx.moveTo(rv.from.x, rv.from.y); 
                ctx.lineTo(rv.to.x, rv.to.y); 
                ctx.stroke();
                
                // Искра
                ctx.fillStyle = 'orange';
                ctx.beginPath(); ctx.arc(rv.to.x, rv.to.y, 5, 0, Math.PI*2); ctx.fill();

                ctx.globalAlpha = 1.0;
                rv.life -= 0.1; // Затухание
                if(rv.life <= 0) e.kill = true; // Помечаем на удаление
            }
        });
        
        // Удаление мертвых эффектов
        for(let i = entities.length - 1; i >= 0; i--) {
            if(entities[i].kill) entities.splice(i, 1);
        }

        ctx.restore();

        // UI Update
        if (player) {
            const pd = player.getComponent('TankData');
            document.getElementById('player-hp').innerText = Math.max(0, Math.round(pd.hp));
            const reloadPerc = Math.min(100, 100 - (pd.reloadTimer / pd.spec.reload * 100));
            document.getElementById('reload-ui').style.width = reloadPerc + '%';
            document.getElementById('reload-ui').style.background = reloadPerc >= 100 ? '#0f0' : '#fa0';
        }
    }
}

// --- 10. ЗАПУСК ИГРЫ (INIT) ---
const world = new World();
const inputSys = new InputSystem();
world.addSystem(inputSys);
world.addSystem(new AISystem());
world.addSystem(new MovementSystem());
world.addSystem(new CombatSystem(world));
const renderSys = new RenderSystem();

// Создание сущностей
const player = world.createEntity()
    .addComponent(new Transform(0, 0))
    .addComponent(new TankData('TT')) // Начинаем на Тяжелом
    .addComponent(new InputState());

const enemy = world.createEntity()
    .addComponent(new Transform(300, 300))
    .addComponent(new TankData('LT'))
    .addComponent(new InputState())
    .addComponent(new AIBehavior());

// Глобальный доступ для UI
window.gameEntities = { player, dummy: enemy };

// Функции UI
window.toggleSettings = (e) => {
    e.stopPropagation();
    const el = document.getElementById('settings-menu');
    el.style.display = el.style.display === 'block' ? 'none' : 'block';
};

window.updateTank = (key, type) => {
    const e = window.gameEntities[key];
    if(e) {
        const data = e.getComponent('TankData');
        const oldHpPerc = data.hp / data.spec.hp;
        data.spec = TANK_SPECS[type];
        data.hp = data.spec.hp * oldHpPerc; // Сохраняем % здоровья при смене
        data.maxHp = data.spec.hp;
    }
};

// Главный цикл
let lastTime = performance.now();
function loop(now) {
    const dt = now - lastTime;
    lastTime = now;
    
    world.update(dt);
    renderSys.update(world.entities);
    
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
